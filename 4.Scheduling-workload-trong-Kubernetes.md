## Kubernetes Scheduler
`Kubernetes Scheduler` (kube-scheduler) là thành phần core trong k8s. Thành phần này sẽ tính toán để tìm node phù hợp nhất cho Pod, sau đó thông báo `kubelet` tại Node phù hợp khởi tạo và chạy Pods.  

<img src="/images/schedule.png">  

### Cách thức hoạt động
`Kubernetes Scheduler` chịu trách nhiệm phân bố Pod tới các Node, luồng hoạt động cơ bản như sau:
Người dùng ra lệnh tạo mới Pod
`kube-scheduler` phát hiện có Pod mới được tạo ra nhưng chưa được gắn cho Node
`kube-scheduler` tìm node phù hợp Pod, sau đó ra lệnh cho `kubelet` khởi tạo Pod
## 1. Variable Configurations
`Variable configurations` (cấu hình biến) trong Kubernetes (k8s) giúp bạn cấu hình ứng dụng của mình cho nhiều môi trường khác nhau (ví dụ như môi trường phát triển, thử nghiệm và sản xuất) một cách dễ dàng và linh hoạt hơn.

Có nhiều cách để cấu hình biến trong Kubernetes, nhưng một cách tiêu biểu là sử dụng `ConfigMap` và `Secret`.
### a. ConfigMap
`ConfigMap` là một tài nguyên Kubernetes được sử dụng để lưu trữ các cấu hình không nhạy cảm, chẳng hạn như thiết lập môi trường, địa chỉ URL và các thông số khác có thể thay đổi, nằm trong một tập hợp key-value. Bạn có thể tạo một ConfigMap bằng cách định nghĩa một file YAML chứa các key-value đó, sau đó sử dụng nó để cấu hình các đối tượng khác trong Kubernetes (ví dụ như Deployment và Pod). Ví dụ của một ConfigMap như sau:
```
  apiVersion: v1
  kind: ConfigMap
  metadata:
    name: app-config
  data:
    APP_ENVIRONMENT: dev
    APP_URL: http://localhost:8080
    APP_TIMEOUT: "30"
```
Trong ví dụ này, chúng ta đã tạo một ConfigMap với tên là "app-config", có chứa ba cấu hình được lưu trữ trong các key-value: APP_ENVIRONMENT, APP_URL và APP_TIMEOUT.
### b. Secret: 
`Secret` cũng là một tài nguyên Kubernetes được sử dụng để lưu trữ các thông tin nhạy cảm như mật khẩu, mã thông báo, chứng chỉ và khóa bí mật. Khác với ConfigMap, Secret được lưu trữ dưới dạng dữ liệu base64, bảo mật hơn so với ConfigMap. Bạn có thể tạo một Secret bằng cách sử dụng lệnh `kubectl` hoặc định nghĩa một file YAML và triển khai nó.

Ví dụ của một Secret như sau:
```
  apiVersion: v1
  kind: Secret
  metadata:
    name: db-credentials
  type: Opaque
  data:
    username: dXNlcg== # "user" được mã hoá dưới dạng base64
    password: cGFzc3dvcmQxMjM= # "password123" được mã hoá dưới dạng base64
```
Trong ví dụ này, chúng ta đã tạo một Secret với tên là "db-credentials", lưu trữ tên đăng nhập và mật khẩu để truy cập vào cơ sở dữ liệu (đã được mã hoá dưới dạng base64).

Sau khi định nghĩa ConfigMap và Secret, bạn có thể sử dụng chúng trong các đối tượng khác của Kubernetes, chẳng hạn như Deployment hoặc Pod. Ví dụ, để sử dụng ConfigMap trong Pod, bạn có thể khai báo chúng trong định nghĩa Pod như sau:
```
  apiVersion: v1
  kind: Pod
  metadata:
    name: myapp
  spec:
    containers:
    - name: myapp
      image: myapp-image
      envFrom:
      - configMapRef:
          name: app-config # tên của ConfigMap
```
Ở đây chúng ta đã định nghĩa một Pod với một container, được cấu hình với "app-config" ConfigMap bằng cách sử dụng `envFrom`. Nó sẽ đưa các cấu hình từ ConfigMap vào trong môi trường để sử dụng trong quá trình khởi động.
## 2. Storage and Usage of Sensitive Information
Kubernetes cung cấp hai giải pháp để lưu trữ và sử dụng thông tin nhạy cảm trong ứng dụng của ta: Secrets và EncryptionConfiguration.

### a. Secrets 
`Secrets` là một tài nguyên Kubernetes được sử dụng để lưu trữ và quản lý các thông tin nhạy cảm như tên đăng nhập, mật khẩu, khóa bí mật, chứng nhận TLS/SSL và nhiều hơn nữa. Secret được tạo ra dưới dạng một tài nguyên Kubernetes, được lưu trữ và truy cập an toàn, và dựa trên RBAC để điều khiển quyền truy cập.

Ta có thể tạo một Secret bằng cách định nghĩa một file YAML và sử dụng lệnh `kubectl` để triển khai nó. Ví dụ, đây là một file YAML định nghĩa một Secret chứa tên đăng nhập và mật khẩu của một cơ sở dữ liệu:
```sh
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
data:
  username: "dXNlcm5hbWU=" # "username" được mã hóa dưới dạng base64
  password: "cGFzc3dvcmQ=" # "password" được mã hóa dưới dạng base64
```

Ta có thể đặt các giá trị tên đăng nhập và mật khẩu của mình vào từng Secret yaml file như trên sau đó khai báo Secret đó trong file cấu hình cho các ứng dụng ta muốn khởi chạy.
```sh
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapplication
spec:
  replicas: 1
  selector:
    matchLabels:
      app: myapplication
  template:
    metadata:
      labels:
        app: myapplication
    spec:
      containers:
      - name: myapplication
        image: myapplication:latest
        ports:
        - containerPort: 8080
        envFrom:
        - secretRef:
            name: db-credentials
```

### b. EncryptionConfiguration 
`EncryptionConfiguration` là một tính năng của Kubernetes, cho phép ta mã hóa dữ liệu nhạy cảm của ứng dụng của ta trong các pod. Có hai cách để mã hóa dữ liệu trong một pod:

- Có thể sử dụng một Volume mật mã hóa trong Pod. Các Volumes này cung cấp truy cập đọc/ghi tới các key trong thư mục `/etc/mlaimencryptionkey` trong filesystem chung.

- Có thể sử dụng một `EncryptionConfiguration` để mật mã hóa dữ liệu của pod. Ví dụ, ta có thể định nghĩa `EncryptionConfiguration` trong file YAML của Pod để sử dụng một file key (private key) để mã hóa các trường trong một tài nguyên YAML.

Trong k8s, file `EncryptionConfiguration` cũng được triển khai theo cách tạo ra một tài nguyên như `secret` giống như file cấu hình cho một pod ví dụ như sau
```sh
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
type: Opaque
data:
  secret.txt: |
    BASE64_ENCODED_DATA
``` 

Ta có thể đặt tỉ lệ bảo mật encryption và khóa bí mật mã hóa dữ liệu được khai báo trong các file YAML cũng như Secrets này.  
## Access to the Cluster by a Container
Để cho phép một container trong cluster Kubernetes có thể truy cập tới thành phần khác trong cluster (ví dụ như pods, services, endpoints), bạn có thể sử dụng các trong số các giải pháp như tạo các service account và cấp quyền cho chúng để có thể truy cập tài nguyên trong cluster.

- Tạo một Service Account: Để tạo một service account mới, bạn có thể sử dụng lệnh `kubectl create serviceaccount`, sau đó sử dụng tài khoản này trong containers. Ví dụ để tạo một service account là `my-service-account`, bạn sử dụng lệnh: 

`kubectl create serviceaccount my-service-account`


- Cấp quyền cho `Service Account`: Sau khi tạo service account, bạn có thể cấp quyền cho nó để có thể truy cập vào các tài nguyên trong cluster. Bạn có thể sử dụng `Role-Based Access Control` (RBAC) để định nghĩa các quyền cho service account. Ví dụ, để cấp quyền cho service account `my-service-account` để truy cập vào tất cả các pods trong namespace hiện tại, bạn sử dụng lệnh sau:
```sh
kubectl apply -f - <<EOF
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: my-service-account-binding
subjects:
- kind: ServiceAccount
  name: my-service-account
  namespace: default
roleRef:
  kind: ClusterRole
  name: view
  apiGroup: rbac.authorization.k8s.io
EOF
```

Với một cluster có nhiều namespaces có thể chỉ rõ namespace điều kiện cho Binding trong trường namespace như ví dụ trên đã làm.

- Sử dụng Service Account trong Container: Để sử dụng service account trong container, bạn có thể sử dụng annotation serviceAccountName trong file deployment YAML để gán service account với container mà bạn muốn chạy. Ví dụ, sau đây là đoạn YAML triển khai một deployment có 3 replicas, ứng dụng nginx, và sử dụng my-service-account để tìm kiếm các tài nguyên trong cluster: 
```sh
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      serviceAccountName: my-service-account
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
```

Trong ví dụ này, chúng ta đã định nghĩa một deployment với 3 replicas, sử dụng service account `my-service-account`, và chạy một container nginx.

Sau khi triển khai, container đó đã được cấp quyền để truy cập
